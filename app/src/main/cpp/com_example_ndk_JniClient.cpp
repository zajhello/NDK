/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_example_ndk_JniClient */

#ifndef _Included_com_example_ndk_JniClient
#define _Included_com_example_ndk_JniClient

#include "string.h"
#include <stdio.h>

#include <android/log.h>
#include <stdlib.h>
// log标签
#define  TAG   "ndk- "
// 定义info信息
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO,TAG,__VA_ARGS__)
// 定义debug信息
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__)
// 定义error信息
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,TAG,__VA_ARGS__)

#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_example_ndk_JniClient
 * Method:    AddStr
 * Signature: (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_example_ndk_JniClient_AddStr
        (JNIEnv *env, jclass arg, jstring instringA, jstring instringB) {
    jstring str = env->NewStringUTF("I am from JNI");
    //将jstring转换成const char*指针，使用const修饰符表示其内容不可被修改
    const char *str1 = env->GetStringUTFChars(instringA, NULL);//C的语法
    //1.访问java.lang.String对应的JNI类型jstring时，没有像访问基本数据类型一样直接使用，
    //因为它在Java是一个引用类型，所以在本地代码中只能通过GetStringUTFChars这样的JNI函数来访问字符串的内容
    const char *str2 = env->GetStringUTFChars(instringB, NULL);


    //4.C语言中，为什么字符串可以赋值给字符指针变量
    char *p, a = '5';
    p = &a;
    p = "abcd";  //但为什么也可以这样赋值？？

//	双引号做了3件事：
//	1.申请了空间(在常量区)，存放了字符串
//	2. 在字符串尾加上了'/0'
//	3.返回地址

    //计算新字符串长度
    int size = strlen(str1) + strlen(str2);

    //char *charPoint = new char[size+1];//C++中就建议使用new和delete 为了兼容,还保留malloc
    char *n_str_point = (char *) malloc(size + 1);//因为malloc返回的指针类型为止,所以需要强制转换 (char *)
    strcpy(n_str_point, str1);//将字符串str1拷贝到字符数组

//    jstring jstr = env->NewStringUTF(env,"输出字符串");//有中文报错  非UTF-8转换UTF
    //http://www.jianshu.com/p/333648d8a998  JNI日志调试中文乱码  android jni 中文乱码,该怎么解决
    //主要是环境问题 .c文件写中文的话 你保存成utf-8   要更改此c文件编码为utf-8
    jstring jstr = env->NewStringUTF("输出字符串"); //有中文报错  非UTF-8转换UTF
    char *outStr;
    outStr = const_cast<char *>(env->GetStringUTFChars(jstr, NULL));
    LOGI("%s", outStr);//将中文先转换为jni层的jstring再转换为c中的字符后输出,不然会乱码
    LOGI("%s", str1);//输出字符串
    LOGI("%s", str2);

    LOGI("%s", "输出字符串长度");
    LOGI("%d", strlen(str1));//输出字符串长度
    LOGI("%d", strlen(str2));

    LOGI("%s", "输出拷贝之后的新字符串");
    LOGI("%s", n_str_point);//输出拷贝之后的新字符串
    LOGI("%d", strlen(n_str_point));

    LOGI("%s", "输出拼接之后的新字符串");
    strcat(n_str_point, str2); //函数原形char *strcat(char *dest, const char *src);
    LOGI("%s", n_str_point);//输出拷贝之后的新字符串
    LOGI("%d", strlen(n_str_point)); //strlen返回长度遇到第一个\n结束 http://www.jianshu.com/p/7fa9f615ee49

    jstring result = env->NewStringUTF(n_str_point);

    //删除刚刚动态分配的内存 避免引起内存泄漏
    //delete[] n_char;//C++
    free(n_str_point); //注意只能释放动态分配的内存
    //free() 只能释放动态分配的内存空间，并不能释放任意的内存。下面的写法是错误的
    //int a[10];
    // ...
    //free(a);

    //释放指针  参照 http://blog.csdn.net/xyang81/article/details/42066665
    env->ReleaseStringUTFChars(jstr, outStr);
    env->ReleaseStringUTFChars(instringA, str1); //前面是jdata后面是cdata
    env->ReleaseStringUTFChars(instringB, str2);

    return result; //需要转换为中间层jstring返回
}


/*
 * Class:     com_example_ndk_JniClient
 * Method:    TestDataTypeJ2C
 * Signature: (SIJFDCZBLjava/lang/String;[ILjava/lang/Object;Lcom/example/ndk/MyJavaClass;)V
 */
JNIEXPORT void JNICALL Java_com_example_ndk_JniClient_TestDataTypeJ2C
        (JNIEnv *env, jclass JniClient, jshort mJshort, jint mJint, jlong mJlong, jfloat mJfloat,
         jdouble mJdouble, jchar mJchar, jboolean mJboolean, jbyte mJbyte, jstring mJstring,
         jintArray mJintArray, jobject mJobject, jobject mJobjectClass) {

    // %d 有符号10进制整数%ld 长整型%hd短整型 %md,m指定的是输出字段的宽度
//     printf("s=%hd, i=%d, l=%ld, f=%f, d=%lf, c=%c, z=%c, b=%d", s, i, l, f, d, c, z, b);
//    short s, int i, long l, float f,double d, char c, boolean z, byte b

    short s = mJshort;
    LOGE("mJshort==>%hd\n", s);
    LOGE("mJint==>%d\n", mJint);
    LOGE("mJlong==>%ld\n", mJlong);
    LOGE("mJfloat==>%f\n", mJfloat);
    LOGE("mJdouble==>%lf\n", mJdouble);
    LOGE("mJchar==>%c\n", mJchar);
    LOGE("mJboolean==>%d\n", mJboolean);
    LOGE("mJbyte==>%d\n", mJbyte);

    //基本数据类型
    //jclass mJclass, jshort mJshort, jint mJint, jlong mJlong, jfloat mJfloat,
    //jdouble mJdouble, jchar mJchar, jboolean mJboolean, jbyte mJbyte

    //引用类型
    //jstring mJstring,
    //jintArray mJintArray

}

/*
 * Class:     com_example_ndk_JniClient
 * Method:    sumArray
 * Signature: ([I)[I
 */
JNIEXPORT jintArray JNICALL Java_com_example_ndk_JniClient_sumArray
        (JNIEnv *env, jclass mJclass, jintArray mJintArray) {
    jint cSum = 0;
    jint cLen = 0;
    //1.获取数组长度
    cLen = env->GetArrayLength(mJintArray);

    //2.根据数组长度和数组元素的数据类型申请存放java数组元素的缓冲区
    //将jarray转换为c可操作的数组
//    jint *cPArray = (jint *) malloc(sizeof(jint) * cLen);
//    if (cPArray == NULL) {
//        return NULL;//可能申请内存空间失败
//    }
//    memset(cPArray, 0, sizeof(jint) * cLen);
//    LOGI("cLen==length>%d\n", cLen);
//    LOGI("cLen==sizeof>%d\n", sizeof(jint) * cLen);
//    //4. 拷贝Java数组中的所有元素到缓冲区中
//    env->GetIntArrayRegion(mJintArray,0,cLen,cPArray); //得到数组方式1  把数据放在缓冲区

// 可能数组中的元素在内存中是不连续的，JVM可能会复制所有原始数据到缓冲区，然后返回这个缓冲区的指针
    jint *cPArray = env->GetIntArrayElements(mJintArray, NULL);
    if (cPArray == NULL) {
        return NULL; // JVM复制原始数据到缓冲区失败
    }

    jint i;
    for (i = 0; i < cLen; ++i) {
        cSum = cSum + cPArray[i];
    }
    LOGI("jSum==>%d\n", cSum);

    //给java层返回数组方式1
    jint cInts[cLen];//定义一个数组
    for (int i = 0; i < cLen; ++i) {
        cInts[i] = cPArray[i];
    }
//length =  sizeof(array) / sizeof(array[0]);  c/c++中求数组长度

    jintArray result;
    result = env->NewIntArray(cLen);
    if (result == NULL) {
        return NULL; /* out of memory error thrown */
    }

    env->SetIntArrayRegion(result, 0, sizeof(cInts) / sizeof(cInts[0]), cInts);

    env->ReleaseIntArrayElements(mJintArray, cPArray, 0);// 释放可能复制的缓冲区

    return result;
}

/*
 * Class:     com_example_ndk_JniClient
 * Method:    getArrayObjectFromC
 * Signature: (I)[[I
 */
JNIEXPORT jobjectArray JNICALL Java_com_example_ndk_JniClient_getArrayObjectFromC
        (JNIEnv *env, jclass jniClient, jint mjint) {

    jobjectArray jobjectArrayResult; //jni中二维数组为对象
    jclass jClassArray;
    //获得一个int型一维数组的一个引用
    jClassArray = env->FindClass("[I");
    if (jClassArray == NULL) {//out of memery
        return NULL;
    }

    // 2.创建一个数组对象（里面每个元素用clsIntArray表示）  参数 JNIEnv*, jsize, jclass, jobject
    jobjectArrayResult = env->NewObjectArray(mjint, jClassArray, NULL);
    if (!jobjectArrayResult) {
        return NULL;
    }

    //为数组元素赋值
    jint i;
    for (i = 0; i < mjint; ++i) {
        jintArray mJintArray; //创建一个一维数组
        mJintArray = env->NewIntArray(mjint);
        if (!mJintArray) {
            return NULL;
        }
        jint mBuff[mjint];
        jint j;
        for (j = 0; j < mjint; j++) {
            mBuff[j] = i + j;
        }

        //数组转换
        env->SetIntArrayRegion(mJintArray, 0, mjint, mBuff);
        //设置数组对象
        env->SetObjectArrayElement(jobjectArrayResult, i, mJintArray);
        env->DeleteLocalRef(mJintArray);
    }
    return jobjectArrayResult;
}

/*
 * Class:     com_example_ndk_JniClient
 * Method:    callJavaStaticMethod
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_example_ndk_JniClient_callJavaStaticMethod
        (JNIEnv *env, jclass cla) {

    jclass mJclass;
    jstring mJstring;
    jmethodID mJStaticmethodID;

    //1.从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象
    mJclass = env->FindClass("com/example/ndk/MyJavaClass");
    if (mJclass == NULL) {
        LOGI("callJavaStaticMethod==>>mJclass==NULL==>>%s", "");
        return;
    }

    // 2、从clazz类中查找callStaticMethod方法
    mJStaticmethodID = env->GetStaticMethodID(mJclass,
                                              "callStaticMethod",
                                              "(Ljava/lang/String;I)V");
    if (mJStaticmethodID == NULL) {
        printf("=====>>>can not foud callStaticMethod");
        return;
    }

    //3、调用clazz类的callStaticMethod静态方法
    mJstring = env->NewStringUTF("FROM JNI");
    env->CallStaticVoidMethod(mJclass, mJStaticmethodID, mJstring, 200);

    // 删除局部引用
    env->DeleteLocalRef(mJstring);
    env->DeleteLocalRef(mJclass);
}

/*
 * Class:     com_example_ndk_JniClient
 * Method:    callJavaInstaceMethod
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_example_ndk_JniClient_callJavaInstaceMethod
        (JNIEnv *env, jclass jniClient) {

    jclass mJclass = NULL;
    jmethodID jmethodID_Construct;//构造方法ID
    jmethodID jmethodID_Method_Instance;//方法的ID
    jobject jobjectMyClass; //类的实例

    //1、从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象
    mJclass = env->FindClass("com/example/ndk/MyJavaClass");
    if (mJclass == NULL) {
        printf("====FindClass  not found \n");
        return;
    }

    // 2、获取类的默认构造方法ID
    jmethodID_Construct = env->GetMethodID(mJclass, "<init>", "()V");
    if (jmethodID_Construct == NULL) {
        printf("GetMethodID not found ==>>jmethodID_Construct");
        return;
    }
    // 3、查找实例方法的ID
    jmethodID_Method_Instance = env->GetMethodID(mJclass,
                                                 "callInstanceMethod", "(Ljava/lang/String;I)V");
    if (jmethodID_Method_Instance == NULL) {
        return;
    }

    // 4、创建该类的实例  调用无参构造方法  如果其它构造方法,后面可传参数
    jobjectMyClass = env->NewObject(mJclass, jmethodID_Construct);
    if (jobjectMyClass == NULL) {
        printf(
                "在com.example.ndk.MyJavaClass 类中找不到callInstanceMethod方法");
        return;
    }

    // 5、调用对象的实例方法
    jstring mJstring = env->NewStringUTF("==I am from Native==");
//    jstring mJstring = env->NewStringUTF(env,"==我来自Native,通过调用java对象方法传递==");
    env->CallVoidMethod(jobjectMyClass, jmethodID_Method_Instance, mJstring, 201);

    // 删除局部引用
    env->DeleteLocalRef(mJstring);
    env->DeleteLocalRef(jobjectMyClass);
    // DeleteLocalRef 只作用jobject
//    env->DeleteLocalRef(jmethodID_Method_Instance);
//    env->DeleteLocalRef(jmethodID_Construct);
}

/*
 * Class:     com_example_ndk_JniClient
 * Method:    accessInstanceField
 * Signature: (Lcom/example/ndk/ClassField;)V
 */
JNIEXPORT void JNICALL Java_com_example_ndk_JniClient_accessInstanceField
        (JNIEnv *env, jclass jniClient, jobject obj) {

    jclass clazz;
    jfieldID fieldId;
    jstring j_str;
    jstring j_newStr;
    const char *c_str = NULL;

    // 1.获取ClassField类的Class引用
    clazz = env->GetObjectClass(obj);
    if (clazz == NULL) {
        return;
    }
    // 2. 获取ClassField类实例变量str的属性ID
    fieldId = env->GetFieldID(clazz, "str", "Ljava/lang/String;");
    if (fieldId == NULL) {
        return;
    }

    // 3. 获取实例变量str的值
    j_str = static_cast<jstring>(env->GetObjectField(obj, fieldId));
    if (j_str == NULL) {
        return;
    }

    // 4. 将unicode编码的java字符串转换成C风格字符串
    c_str = env->GetStringUTFChars(j_str, NULL);
    if (c_str == NULL) {
        return;
    }

    printf("In C--->ClassField.str = %s\n", c_str);
    env->ReleaseStringUTFChars(j_str, c_str);

    // 5. 修改实例变量str的值
    j_newStr = env->NewStringUTF("this is c String");
    if (j_newStr == NULL) {
        return;
    }
    // 修改Jobject对象参数
    env->SetObjectField(obj, fieldId, j_newStr);

    // 6.删除局部引用
    env->DeleteLocalRef(clazz);
    env->DeleteLocalRef(j_str);
    env->DeleteLocalRef(j_newStr);
    //JNIEnv*, jobject  返回的非object,不能使用 DeleteLocalRef
    //使用NewObject就会返回创建出来的实例的局部引用 可  DeleteLocalRef
}

/*
 * Class:     com_example_ndk_JniClient
 * Method:    accessStaticField
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_example_ndk_JniClient_accessStaticField
        (JNIEnv *env, jclass jcl) {

    jclass clazz;
    jfieldID fid;
    jint num;

    //1.获取ClassField类的Class引用
    clazz = env->FindClass("com/example/ndk/ClassField");
    if (clazz == NULL) {
        return;
    }
    //2.获取ClassField类静态变量num的属性ID
    fid = env->GetStaticFieldID(clazz, "num", "I");
    if (fid == NULL) {
        return;
    }

    // 3.获取静态变量num的值
    num = env->GetStaticIntField(clazz, fid);
    printf("In C ---> ClassField.num = %d\n", num);

    // 4.修改静态变量num的值
    env->SetStaticIntField(clazz, fid, 80);

    // 删除属部引用
    env->DeleteLocalRef(clazz);

}

/*
 * Class:     com_example_ndk_JniClient
 * Method:    callSuperInstanceMethod
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_example_ndk_JniClient_callSuperInstanceMethod
        (JNIEnv *env, jclass cls) {

    LOGI("Java_com_example_ndk_JniClient_callSuperInstanceMethod");//可写任意参数

    jclass cls_cat;
    jclass cls_animal;
    jmethodID mid_cat_init;
    jmethodID mid_run;
    jmethodID mid_getName;
    jstring c_str_name;
    jobject obj_cat;
    const char *name = NULL;

    // 1、获取Cat类的class引用
    cls_cat = env->FindClass("com/example/ndk/Cat");
    if (cls_cat == NULL) {
        return;
    }

    // 2、获取Cat的构造方法ID(构造方法的名统一为：<init>)
    mid_cat_init = env->GetMethodID(cls_cat, "<init>", "(Ljava/lang/String;)V");
    if (mid_cat_init == NULL) {
        return;
    }

    // 3、创建一个String对象，作为构造方法的参数
    c_str_name = env->NewStringUTF("Tom Cat");
    LOGI("%s", env->GetStringUTFChars(c_str_name, NULL));
    if (c_str_name == NULL) {
        return;
    }

    //  4、创建Cat对象的实例(调用对象的构造方法并初始化对象)
    obj_cat = env->NewObject(cls_cat, mid_cat_init, c_str_name);
    if (obj_cat == NULL) {
        return;
    }

    // 5、调用Cat父类Animal的run和getName方法
    cls_animal = env->FindClass("com/example/ndk/Animal");
    if (cls_animal == NULL) {
        return;
    }

    // 例1： 调用父类的run方法
    mid_run = env->GetMethodID(cls_animal, "run", "()V");
    if (mid_run == NULL) {
        return;
    }

    // 注意：obj_cat是Cat的实例，cls_animal是Animal的Class引用，mid_run是Animal类中的方法ID
    env->CallNonvirtualVoidMethod(obj_cat, cls_animal, mid_run);

    // 例2：调用父类的getName方法
    // 获取父类Animal中getName方法的id
    mid_getName = env->GetMethodID(cls_animal, "getName", "()Ljava/lang/String;");
    if (mid_getName == NULL) {
        return;
    }

    c_str_name = (jstring) env->CallNonvirtualObjectMethod(obj_cat, cls_animal, mid_getName);
    name = env->GetStringUTFChars(c_str_name, NULL);
//    printf("In C: Animal Name is %s\n", name);
    LOGI("In C: Animal Name is ", name);//
    // 释放从java层获取到的字符串所分配的内存
    env->ReleaseStringUTFChars(c_str_name, name);

    quit:
    // 删除局部引用（jobject或jobject的子类才属于引用变量），允许VM释放被局部变量所引用的资源
    env->DeleteLocalRef(cls_cat);
    env->DeleteLocalRef(cls_animal);
    env->DeleteLocalRef(c_str_name);
    env->DeleteLocalRef(obj_cat);
}

#ifdef __cplusplus
}
#endif
#endif
